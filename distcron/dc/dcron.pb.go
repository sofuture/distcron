// Code generated by protoc-gen-go.
// source: dcron.proto
// DO NOT EDIT!

/*
Package dc is a generated protocol buffer package.

It is generated from these files:
	dcron.proto

It has these top-level messages:
	Job
	JobHandle
	JobStatus
	Output
*/
package dc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Job struct {
	ContainerName string  `protobuf:"bytes,1,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	CpuLimit      float32 `protobuf:"fixed32,2,opt,name=cpu_limit,json=cpuLimit" json:"cpu_limit,omitempty"`
	MemLimitMb    int64   `protobuf:"varint,3,opt,name=mem_limit_mb,json=memLimitMb" json:"mem_limit_mb,omitempty"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Job) GetContainerName() string {
	if m != nil {
		return m.ContainerName
	}
	return ""
}

func (m *Job) GetCpuLimit() float32 {
	if m != nil {
		return m.CpuLimit
	}
	return 0
}

func (m *Job) GetMemLimitMb() int64 {
	if m != nil {
		return m.MemLimitMb
	}
	return 0
}

type JobHandle struct {
	Handle string `protobuf:"bytes,1,opt,name=handle" json:"handle,omitempty"`
}

func (m *JobHandle) Reset()                    { *m = JobHandle{} }
func (m *JobHandle) String() string            { return proto.CompactTextString(m) }
func (*JobHandle) ProtoMessage()               {}
func (*JobHandle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *JobHandle) GetHandle() string {
	if m != nil {
		return m.Handle
	}
	return ""
}

type JobStatus struct {
	Status string `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
}

func (m *JobStatus) Reset()                    { *m = JobStatus{} }
func (m *JobStatus) String() string            { return proto.CompactTextString(m) }
func (*JobStatus) ProtoMessage()               {}
func (*JobStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *JobStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type Output struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Output) Reset()                    { *m = Output{} }
func (m *Output) String() string            { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()               {}
func (*Output) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Output) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Job)(nil), "dc.Job")
	proto.RegisterType((*JobHandle)(nil), "dc.JobHandle")
	proto.RegisterType((*JobStatus)(nil), "dc.JobStatus")
	proto.RegisterType((*Output)(nil), "dc.Output")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DistCron service

type DistCronClient interface {
	RunJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*JobHandle, error)
	GetJobOutput(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (DistCron_GetJobOutputClient, error)
	GetJobStatus(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (*JobStatus, error)
	StopJob(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (*JobStatus, error)
	// internal API
	RunJobOnThisNode(ctx context.Context, in *Job, opts ...grpc.CallOption) (*JobHandle, error)
}

type distCronClient struct {
	cc *grpc.ClientConn
}

func NewDistCronClient(cc *grpc.ClientConn) DistCronClient {
	return &distCronClient{cc}
}

func (c *distCronClient) RunJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*JobHandle, error) {
	out := new(JobHandle)
	err := grpc.Invoke(ctx, "/dc.DistCron/RunJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distCronClient) GetJobOutput(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (DistCron_GetJobOutputClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DistCron_serviceDesc.Streams[0], c.cc, "/dc.DistCron/GetJobOutput", opts...)
	if err != nil {
		return nil, err
	}
	x := &distCronGetJobOutputClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DistCron_GetJobOutputClient interface {
	Recv() (*Output, error)
	grpc.ClientStream
}

type distCronGetJobOutputClient struct {
	grpc.ClientStream
}

func (x *distCronGetJobOutputClient) Recv() (*Output, error) {
	m := new(Output)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *distCronClient) GetJobStatus(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := grpc.Invoke(ctx, "/dc.DistCron/GetJobStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distCronClient) StopJob(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := grpc.Invoke(ctx, "/dc.DistCron/StopJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distCronClient) RunJobOnThisNode(ctx context.Context, in *Job, opts ...grpc.CallOption) (*JobHandle, error) {
	out := new(JobHandle)
	err := grpc.Invoke(ctx, "/dc.DistCron/RunJobOnThisNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DistCron service

type DistCronServer interface {
	RunJob(context.Context, *Job) (*JobHandle, error)
	GetJobOutput(*JobHandle, DistCron_GetJobOutputServer) error
	GetJobStatus(context.Context, *JobHandle) (*JobStatus, error)
	StopJob(context.Context, *JobHandle) (*JobStatus, error)
	// internal API
	RunJobOnThisNode(context.Context, *Job) (*JobHandle, error)
}

func RegisterDistCronServer(s *grpc.Server, srv DistCronServer) {
	s.RegisterService(&_DistCron_serviceDesc, srv)
}

func _DistCron_RunJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Job)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistCronServer).RunJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dc.DistCron/RunJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistCronServer).RunJob(ctx, req.(*Job))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistCron_GetJobOutput_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JobHandle)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DistCronServer).GetJobOutput(m, &distCronGetJobOutputServer{stream})
}

type DistCron_GetJobOutputServer interface {
	Send(*Output) error
	grpc.ServerStream
}

type distCronGetJobOutputServer struct {
	grpc.ServerStream
}

func (x *distCronGetJobOutputServer) Send(m *Output) error {
	return x.ServerStream.SendMsg(m)
}

func _DistCron_GetJobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobHandle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistCronServer).GetJobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dc.DistCron/GetJobStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistCronServer).GetJobStatus(ctx, req.(*JobHandle))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistCron_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobHandle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistCronServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dc.DistCron/StopJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistCronServer).StopJob(ctx, req.(*JobHandle))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistCron_RunJobOnThisNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Job)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistCronServer).RunJobOnThisNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dc.DistCron/RunJobOnThisNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistCronServer).RunJobOnThisNode(ctx, req.(*Job))
	}
	return interceptor(ctx, in, info, handler)
}

var _DistCron_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dc.DistCron",
	HandlerType: (*DistCronServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunJob",
			Handler:    _DistCron_RunJob_Handler,
		},
		{
			MethodName: "GetJobStatus",
			Handler:    _DistCron_GetJobStatus_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _DistCron_StopJob_Handler,
		},
		{
			MethodName: "RunJobOnThisNode",
			Handler:    _DistCron_RunJobOnThisNode_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetJobOutput",
			Handler:       _DistCron_GetJobOutput_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dcron.proto",
}

func init() { proto.RegisterFile("dcron.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 288 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x91, 0xdf, 0x4a, 0xc3, 0x30,
	0x1c, 0x85, 0x97, 0x4d, 0xba, 0xed, 0xe7, 0x26, 0x92, 0x0b, 0x19, 0xd3, 0x8b, 0x12, 0x11, 0x2a,
	0x68, 0x11, 0x7d, 0x04, 0x05, 0xa5, 0xe8, 0x06, 0x9d, 0xf7, 0x25, 0xff, 0x60, 0xc5, 0x25, 0x29,
	0x6d, 0xf2, 0xca, 0x3e, 0x87, 0x34, 0x49, 0x05, 0x05, 0xf1, 0xee, 0x9c, 0x9e, 0x8f, 0xe6, 0x0b,
	0x81, 0x63, 0xc1, 0x5b, 0xa3, 0xf3, 0xa6, 0x35, 0xd6, 0xe0, 0xb1, 0xe0, 0xe4, 0x03, 0x26, 0x85,
	0x61, 0xf8, 0x0a, 0x4e, 0xb8, 0xd1, 0x96, 0xd6, 0x5a, 0xb6, 0x95, 0xa6, 0x4a, 0xae, 0x50, 0x8a,
	0xb2, 0x79, 0xb9, 0xfc, 0xfe, 0xba, 0xa1, 0x4a, 0xe2, 0x73, 0x98, 0xf3, 0xc6, 0x55, 0x87, 0x5a,
	0xd5, 0x76, 0x35, 0x4e, 0x51, 0x36, 0x2e, 0x67, 0xbc, 0x71, 0xaf, 0x7d, 0xc7, 0x29, 0x2c, 0x94,
	0x54, 0x61, 0xac, 0x14, 0x5b, 0x4d, 0x52, 0x94, 0x4d, 0x4a, 0x50, 0x52, 0xf9, 0xfd, 0x8d, 0x91,
	0x4b, 0x98, 0x17, 0x86, 0xbd, 0x50, 0x2d, 0x0e, 0x12, 0x9f, 0x41, 0xb2, 0xf7, 0x29, 0x1e, 0x15,
	0x5b, 0x84, 0x76, 0x96, 0x5a, 0xd7, 0xf5, 0x50, 0xe7, 0xd3, 0x00, 0x85, 0x46, 0x2e, 0x20, 0xd9,
	0x3a, 0xdb, 0x38, 0x8b, 0x31, 0x1c, 0x09, 0x6a, 0xa9, 0xdf, 0x17, 0xa5, 0xcf, 0xf7, 0x9f, 0x08,
	0x66, 0x4f, 0x75, 0x67, 0x1f, 0x5b, 0xa3, 0x31, 0x81, 0xa4, 0x74, 0xba, 0xbf, 0xe4, 0x34, 0x17,
	0x3c, 0x2f, 0x0c, 0x5b, 0x2f, 0x63, 0x08, 0x26, 0x64, 0x84, 0x6f, 0x61, 0xf1, 0x2c, 0x6d, 0x61,
	0x58, 0xfc, 0xe9, 0x4f, 0x60, 0x0d, 0x7d, 0x0d, 0x13, 0x19, 0xdd, 0x21, 0x9c, 0x0f, 0x78, 0xb4,
	0xfc, 0x85, 0x0f, 0x35, 0xac, 0x64, 0x84, 0xaf, 0x61, 0xba, 0xb3, 0xa6, 0xe9, 0x1d, 0xfe, 0x43,
	0x6f, 0xe0, 0x34, 0xd8, 0x6e, 0xf5, 0xfb, 0xbe, 0xee, 0x36, 0x46, 0xc8, 0xbf, 0xbd, 0x59, 0xe2,
	0x1f, 0xf2, 0xe1, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x97, 0xa7, 0x0f, 0x02, 0xd7, 0x01, 0x00, 0x00,
}
