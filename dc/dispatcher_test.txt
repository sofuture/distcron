package dc

import (
	"testing"
)

type testRpc struct {
	leader     string
	node       string
	nodeRpc    map[string]string
	nodeClient map[string]DistCronClient
}

func tNewTestRpc(nodeClient map[string]DistCronClient) map[string]RpcInfo {
	nodeRpc := map[string]string{}
	rpcs := map[string]RpcInfo{}
	leader := true

	for name, client := range nodeClient {
		rpcs[name] = &testRpc{
			nodeClient: nodeClient,
			nodeRpc:    nodeRpc,
			leader:     leader,
		}
		leader = false
	}

	return rpcs
}

func (r *testRpc) GetNodeName() {
	return r.node
}

func (r *testRpc) IsLeader() {
	return r.leader == r.node
}

func (r *testRpc) GetLeaderNode() (string, error) {
	return r.leader, nil
}

func (r *testRpc) SetRpcForNode(node, addr string) error {
	r.nodeRpc[node] = addr
}

func (r *testRpc) GetRpcForNode(node string) (DistCronClient, error) {
	return r.nodeClient[node]
}

type tDcClient struct {
	runJobOnThisNodeTestFn func(r *tDcClient, t *testing.T) (*JobHandle, error)
}

func (c *tDcClient) RunJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*JobHandle, error) {
	return nil, nil
}
func (c *tDcClient) GetJobOutput(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (DistCron_GetJobOutputClient, error) {
	return nil, nil
}
func (c *tDcClient) GetJobStatus(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (*JobStatus, error) {
	return nil, nil
}
func (c *tDcClient) StopJob(ctx context.Context, in *JobHandle, opts ...grpc.CallOption) (*JobStatus, error) {
	return nil, nil
}

func (c *tDcClient) RunJobOnThisNode(ctx context.Context, in *Job, opts ...grpc.CallOption) (*JobHandle, error) {
	return tDcClient.runJobOnThisNodeTestFn()
}

/*
 	Live Serf, but telemetry is faked to simulate various conditions

	1. Dispatch to single node (leader) - success
	2. First node overloaded, second free node joins cluster. Dispatch --> second node should get a job.
	3. Flappy node scenario : first node should be overloaded, and second node should be free but expose errors.
	4. Send more jobs then there are resources --> should fail with ENoResources
*/
func TestDispatch(t *testing.T) {

}

/*
 * send a job, it should get dispatched to another node

 node *Node, api RpcInfo, telemetryChannel chan *TelemetryInfo
*/
func TestDispatcher(t *testing.T) {
	node1 := makeTestNode(t, "one", 5001)
	node2 := makeTestNode(t, "two", 5002)

	jobChannel := make(chan *Job, C_CHAN_BUFFER)
	statusChannel := make(chan *JobStatus, C_CHAN_BUFFER)
	dispatcher := NewDispatcher(node1, jobChannel, statusChannel)

	// 1. send job to single node should fail, as no runners
	jobChannel <- &Job{Name: "test1"}
	if resp := <-statusChannel; resp.State != JobStateNoResources {
		t.Error(resp)
	}

	// 2. make second node join cluster, now job should get dispatched to it
	if _, err := node2.serf.Join([]string{"127.0.0.1:5001"}, true); err != nil {
		t.Error(err)
	}

	jobChannel <- &Job{Name: "test2"}
	if resp := <-statusChannel; resp.State != JobStateDispatched {
		t.Error(resp)
	}

	// 3. leave cluster, now again should get no resources
	node2.serf.Leave()
	jobChannel <- &Job{Name: "test3"}
	if resp := <-statusChannel; resp.State != JobStateNoResources {
		t.Error(resp)
	}

	dispatcher.Stop()

	node1.serf.Shutdown()
	node2.serf.Shutdown()
}
